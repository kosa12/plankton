{"task_id": "ClassEval_0", "predict": ["\"\"\"Access gateway filtering for authentication and access log recording.\"\"\"\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass AccessGatewayFilter:\n    \"\"\"Filter for authentication and access log recording.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the gateway filter.\"\"\"\n        self.current_user = None\n\n    def filter(self, request):\n        \"\"\"Filter the incoming request based on certain rules and conditions.\n\n        :param request: dict, the incoming request details\n        :return: bool, True if the request is allowed, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.filter({'path': '/login', 'method': 'POST'})\n        True\n\n        \"\"\"\n        path = request.get(\"path\", \"\")\n        if AccessGatewayFilter.is_start_with(path):\n            user = AccessGatewayFilter.get_jwt_user(request)\n            if user:\n                self.set_current_user_info_and_log(user)\n            return True\n        return True\n\n    @staticmethod\n    def is_start_with(request_uri):\n        \"\"\"Check if the request URI starts with certain prefixes.\n\n        Currently, the prefixes being checked are \"/api\" and \"/login\".\n        :param request_uri: str, the URI of the request\n        :return: bool, True if the URI starts with certain prefixes, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.is_start_with('/api/data')\n        True\n\n        \"\"\"\n        return request_uri.startswith(\"/api\") or request_uri.startswith(\"/login\")\n\n    @staticmethod\n    def get_jwt_user(request):\n        \"\"\"Get the user information from the JWT token in the request.\n\n        :param request: dict, the incoming request details\n        :return: dict or None, the user information if the token is valid, None otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.get_jwt_user({\n        ...     'headers': {'Authorization': {'user': {'name': 'user1'},\n        ...     'jwt': 'user1'+str(datetime.date.today())}}})\n        {'user': {'name': 'user1'}\n\n        \"\"\"\n        headers = request.get(\"headers\", {})\n        auth = headers.get(\"Authorization\", {})\n        if isinstance(auth, dict) and \"user\" in auth:\n            return {\"user\": auth[\"user\"]}\n        return None\n\n    def set_current_user_info_and_log(self, user):\n        \"\"\"Set the current user information and log the access.\n\n        :param user: dict, the user information\n        :return: None\n        >>> filter = AccessGatewayFilter()\n        >>> user = {'name': 'user1', 'address': '127.0.0.1'}\n        >>> filter.set_current_user_info_and_log(user)\n\n        \"\"\"\n        self.current_user = user\n        logger.info(\"User access: %s\", user)\n"]}
{"task_id": "ClassEval_1", "predict": ["\"\"\"Area calculator for various geometric shapes.\"\"\"\n\nimport math\n\n\nclass AreaCalculator:\n    \"\"\"Calculate the area of different shapes.\"\"\"\n\n    def __init__(self, radius):\n        \"\"\"Initialize the radius for shapes.\n\n        :param radius: float\n        \"\"\"\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        \"\"\"Calculate the area of circle based on self.radius.\n\n        :return: area of circle, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_circle_area()\n        12.566370614359172\n        \"\"\"\n        return math.pi * self.radius**2\n\n    def calculate_sphere_area(self):\n        \"\"\"Calculate the area of sphere based on self.radius.\n\n        :return: area of sphere, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sphere_area()\n        50.26548245743669\n        \"\"\"\n        return 4 * math.pi * self.radius**2\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"Calculate the area of cylinder based on self.radius and height.\n\n        :param height: height of cylinder, float\n        :return: area of cylinder, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_cylinder_area(3)\n        62.83185307179586\n        \"\"\"\n        return 2 * math.pi * self.radius * (height + self.radius)\n\n    def calculate_sector_area(self, angle):\n        \"\"\"Calculate the area of sector based on self.radius and angle.\n\n        :param angle: angle of sector, float\n        :return: area of sector, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sector_area(math.pi)\n        6.283185307179586\n        \"\"\"\n        return (angle * self.radius**2) / 2\n\n    @staticmethod\n    def calculate_annulus_area(inner_radius, outer_radius):\n        \"\"\"Calculate the area of annulus based on inner_radius and out_radius.\n\n        :param inner_radius: inner radius of sector, float\n        :param outer_radius: outer radius of sector, float\n        :return: area of annulus, float\n        >>> areaCalculator.calculate_annulus_area(2, 3)\n        15.707963267948966\n        \"\"\"\n        return math.pi * (outer_radius**2 - inner_radius**2)\n"]}
{"task_id": "ClassEval_10", "predict": ["\"\"\"Binary data processing module.\"\"\"\n\nBITS_PER_BYTE = 8\n\n\nclass BinaryDataProcessor:\n    \"\"\"Process binary data with cleaning, analysis, and encoding conversion.\"\"\"\n\n    def __init__(self, binary_string):\n        \"\"\"Initialize with a binary string and clean non-binary characters.\"\"\"\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        \"\"\"Clean the binary string by removing all non-binary characters.\n\n        >>> bdp = BinaryDataProcessor(\"01101000daf3e4r01100101011011000110110001101111\")\n        >>> bdp.clean_non_binary_chars()\n        >>> bdp.binary_string\n        '0110100001100101011011000110110001101111'\n\n        \"\"\"\n        self.binary_string = \"\".join(c for c in self.binary_string if c in \"01\")\n\n    def calculate_binary_info(self):\n        \"\"\"Calculate binary string info including zero/one percentages and bit length.\n\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.calculate_binary_info()\n        {'Zeroes': 0.475, 'Ones': 0.525, 'Bit length': 40}\n\n        \"\"\"\n        bit_length = len(self.binary_string)\n        zeroes_count = self.binary_string.count(\"0\")\n        ones_count = self.binary_string.count(\"1\")\n        return {\n            \"Zeroes\": round(zeroes_count / bit_length, 3),\n            \"Ones\": round(ones_count / bit_length, 3),\n            \"Bit length\": bit_length,\n        }\n\n    def convert_to_ascii(self):\n        \"\"\"Convert the binary string to ASCII string.\n\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_ascii()\n        'hello'\n\n        \"\"\"\n        result = \"\"\n        for i in range(0, len(self.binary_string), BITS_PER_BYTE):\n            byte = self.binary_string[i : i + BITS_PER_BYTE]\n            if len(byte) == BITS_PER_BYTE:\n                result += chr(int(byte, 2))\n        return result\n\n    def convert_to_utf8(self):\n        \"\"\"Convert the binary string to UTF-8 string.\n\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_utf8()\n        'hello'\n\n        \"\"\"\n        byte_array = bytearray()\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i : i + 8]\n            if len(byte) == BITS_PER_BYTE:\n                byte_array.append(int(byte, 2))\n        return byte_array.decode(\"utf-8\")\n"]}
{"task_id": "ClassEval_11", "predict": ["\"\"\"Bit status utility module.\"\"\"\n\n\nclass BitStatusUtil:\n    \"\"\"Utility class for manipulating and checking status using bitwise operations.\"\"\"\n\n    @staticmethod\n    def add(states, stat):\n        \"\"\"Add a status to the current status and check parameter legality.\n\n        :param states: Current status,int.\n        :param stat: Status to be added,int.\n        :return: The status after adding the status,int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.add(2,4)\n        6\n\n        \"\"\"\n        BitStatusUtil.check([states, stat])\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        \"\"\"Check if the current status contains the specified status.\n\n        :param states: Current status,int.\n        :param stat: Specified status,int.\n        :return: True if the current status contains the specified status,otherwise False,bool.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.has(6,2)\n        True\n\n        \"\"\"\n        BitStatusUtil.check([states, stat])\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states, stat):\n        \"\"\"Remove the specified status from the current status.\n\n        :param states: Current status,int.\n        :param stat: Specified status,int.\n        :return: The status after removing the specified status,int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.remove(6,2)\n        4\n\n        \"\"\"\n        BitStatusUtil.check([states, stat])\n        return states & ~stat\n\n    @staticmethod\n    def check(args):\n        \"\"\"Check if the parameters are legal.\n\n        Args must be >= 0 and even, otherwise raise ValueError.\n        :param args: Parameters to be checked,list.\n        :return: None.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.check([2,3,4])\n        Traceback (most recent call last):\n        ...\n        ValueError: 3 not even\n        \"\"\"\n        for arg in args:\n            if arg < 0 or arg % 2 != 0:\n                msg = f\"{arg} not even\"\n                raise ValueError(msg)\n"]}
{"task_id": "ClassEval_12", "predict": ["\"\"\"Blackjack game implementation.\"\"\"\n\nimport random\n\nBLACKJACK_MAX = 21\n\n\nclass BlackjackGame:\n    \"\"\"Blackjack game with deck creation, hand evaluation, and winner determination.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand.\n\n        While initializing deck attribute, call the create_deck method to generate.\n        The deck stores 52 rondom order poker with the Jokers removed, format is ['AS', '2S', ...].\n        player_hand is a list which stores player's hand cards.\n        dealer_hand is is a list which stores dealer's hand cards.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    @staticmethod\n    def create_deck():\n        \"\"\"Create a deck of 52 cards, which stores 52 rondom order poker with the Jokers removed.\n\n        :return: a list of 52 rondom order poker with the Jokers removed, format is ['AS', '2S', ...].\n        >>> black_jack_game = BlackjackGame()\n        >>> black_jack_game.create_deck()\n        ['QD', '9D', 'JC', 'QH', '2S', 'JH', '7D', '6H', '9S', '5C', '7H', 'QS', '5H',\n        '6C', '7C', '3D', '10C', 'AD', '4C', '5D', 'AH', '2D', 'QC', 'KH', '9C', '9H',\n        '4H', 'JS', '6S', '8H', '8C', '4S', '3H', '10H', '7S', '6D', '3C', 'KC', '3S',\n        '2H', '10D', 'KS', '4D', 'AC', '10S', '2C', 'KD', '5S', 'JD', '8S', 'AS', '8D']\n        \"\"\"\n        suits = [\"S\", \"H\", \"D\", \"C\"]\n        ranks = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\n        deck = [rank + suit for suit in suits for rank in ranks]\n        random.shuffle(deck)\n        return deck\n\n    @staticmethod\n    def calculate_hand_value(hand):\n        \"\"\"Calculate the value of the poker cards stored in hand list.\n\n        According to the rules of the Blackjack Game,\n        if the card is a digit, its value is added to the total hand value.\n        Value of J, Q, or K is 10, while Aces are worth 11.\n        If the total hand value exceeds 21 and there are Aces present, one Ace is treated\n        as having a value of 1 instead of 11, until the hand value is less than or equal\n        to 21, or all Aces have been counted as value of 1.\n        :param hand: list\n        :return: the value of the poker cards stored in hand list, a number.\n        >>> black_jack_game.calculate_hand_value(['QD', '9D', 'JC', 'QH', 'AS'])\n        40\n        \"\"\"\n        total = 0\n        aces = 0\n\n        for card in hand:\n            rank = card[:-1]\n\n            if rank == \"A\":\n                total += 11\n                aces += 1\n            elif rank in {\"J\", \"Q\", \"K\"}:\n                total += 10\n            else:\n                total += int(rank)\n\n        while total > BLACKJACK_MAX and aces > 0:\n            total -= 10\n            aces -= 1\n\n        return total\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"Determine the winner of a game by comparing the hand values of the player and dealer.\n\n        Rule:\n        If both players have hand values that are equal to or less than 21, the winner is the\n        one whose hand value is closer to 21. Otherwise, the winner is the one with the lower\n        hand value.\n        :param player_hand: list\n        :param dealer_hand: list\n        :return: the result of the game, only two certain str: 'Dealer wins' or 'Player wins'\n        >>> black_jack_game.check_winner(['QD', '9D', 'JC', 'QH', 'AS'], ['QD', '9D', 'JC', 'QH', '2S'])\n        'Player wins'\n        \"\"\"\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n\n        if player_value <= BLACKJACK_MAX and dealer_value <= BLACKJACK_MAX:\n            return \"Player wins\" if player_value >= dealer_value else \"Dealer wins\"\n        if player_value > BLACKJACK_MAX and dealer_value > BLACKJACK_MAX:\n            return \"Player wins\" if player_value <= dealer_value else \"Dealer wins\"\n        return \"Player wins\" if player_value <= BLACKJACK_MAX else \"Dealer wins\"\n"]}
{"task_id": "ClassEval_13", "predict": ["\"\"\"Book management module.\"\"\"\n\n\nclass BookManagement:\n    \"\"\"Book management system for adding, removing, and viewing books in inventory.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the inventory of Book Manager.\"\"\"\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        \"\"\"Add one or several books to inventory which is sorted by book title.\n\n        :param title: str, the book title\n        :param quantity: int, default value is 1.\n        \"\"\"\n        if title in self.inventory:\n            self.inventory[title] += quantity\n        else:\n            self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        \"\"\"Remove one or several books from inventory which is sorted by book title.\n\n        Raise false while get invalid input.\n        :param title: str, the book title\n        :param quantity: int\n        \"\"\"\n        if title not in self.inventory or quantity > self.inventory[title]:\n            return False\n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del self.inventory[title]\n        return True\n\n    def view_inventory(self):\n        \"\"\"Get the inventory of the Book Management.\n\n        :return self.inventory: dictionary, {title(str): quantity(int), ...}\n        >>> bookManagement = BookManagement()\n        >>> bookManagement.add_book(\"book1\", 1)\n        >>> bookManagement.add_book(\"book2\", 1)\n        >>> bookManagement.view_inventory()\n        {'book1': 1, 'book2': 1}\n        \"\"\"\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        \"\"\"Get the quantity of a book.\n\n        :param title: str, the title of the book.\n        :return quantity: the quantity of this book title. return 0 when the title does not exist in self.invenroty\n        >>> bookManagement = BookManagement()\n        >>> bookManagement.add_book(\"book1\", 1)\n        >>> bookManagement.view_book_quantity(\"book3\")\n        0\n        \"\"\"\n        return self.inventory.get(title, 0)\n"]}
{"task_id": "ClassEval_14", "predict": ["\"\"\"Book management database module.\"\"\"\n\nimport sqlite3\n\n\nclass BookManagementDB:\n    \"\"\"Book management system for adding, removing, updating, and searching books.\"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"Initialize the database connection and cursor.\n\n        Creates the book table if it does not already exist.\n\n        :param db_name: str, the name of db file\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        \"\"\"Create the book table in the database if it does not already exist.\n\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        \"\"\"\n        self.cursor.execute(\n            \"\"\"\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                author TEXT NOT NULL,\n                availability INTEGER NOT NULL DEFAULT 1\n            )\n            \"\"\"\n        )\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        \"\"\"Add a book to the database with the specified title and author.\n\n        Sets its availability to 1 as free to borrow.\n\n        :param title: str, book title\n        :param author: str, author name\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'author')\n        \"\"\"\n        self.cursor.execute(\n            \"INSERT INTO books (title, author, availability) VALUES (?, ?, 1)\",\n            (title, author),\n        )\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        \"\"\"Remove a book from the database based on the given book ID.\n\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.remove_book(1)\n        \"\"\"\n        self.cursor.execute(\"DELETE FROM books WHERE id = ?\", (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        \"\"\"Mark a book as borrowed in the database based on the given book ID.\n\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.borrow_book(1)\n        \"\"\"\n        self.cursor.execute(\"UPDATE books SET availability = 0 WHERE id = ?\", (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        \"\"\"Mark a book as returned in the database based on the given book ID.\n\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.return_book(1)\n        \"\"\"\n        self.cursor.execute(\"UPDATE books SET availability = 1 WHERE id = ?\", (book_id,))\n        self.connection.commit()\n\n    def search_books(self):\n        \"\"\"Retrieve all books from the database and return their information.\n\n        :return books: list[tuple], the information of all books in database\n        >>> book_db.search_books()\n        [(1, 'book1', 'author', 1)]\n        \"\"\"\n        self.cursor.execute(\"SELECT id, title, author, availability FROM books\")\n        return self.cursor.fetchall()\n"]}
{"task_id": "ClassEval_15", "predict": ["\"\"\"Boyer-Moore string search algorithm implementation.\"\"\"\n\n\nclass BoyerMooreSearch:\n    \"\"\"Implement the Boyer-Moore algorithm for string searching.\"\"\"\n\n    def __init__(self, text, pattern):\n        \"\"\"Initialize the BoyerMooreSearch class with the given text and pattern.\n\n        :param text: The text to be searched, str.\n        :param pattern: The pattern to be searched for, str.\n        \"\"\"\n        self.text, self.pattern = text, pattern\n        self.textLen, self.patLen = len(text), len(pattern)\n\n    def match_in_pattern(self, char):\n        \"\"\"Find the rightmost occurrence of a character in the pattern.\n\n        :param char: The character to be searched for, str.\n        :return: The index of the rightmost occurrence of the character in the pattern, int.\n        >>> boyerMooreSearch = BoyerMooreSearch(\"ABAABA\", \"AB\")\n        >>> boyerMooreSearch.match_in_pattern(\"A\")\n        0\n\n        \"\"\"\n        for i in range(self.patLen - 1, -1, -1):\n            if self.pattern[i] == char:\n                return i\n        return -1\n\n    def mismatch_in_text(self, current_pos):\n        \"\"\"Determine the position of the first mismatch between the pattern and the text.\n\n        :param current_pos: The current position in the text, int.\n        :return: The position of the first mismatch between the pattern and the text, int, otherwise -1.\n        >>> boyerMooreSearch = BoyerMooreSearch(\"ABAABA\", \"ABC\")\n        >>> boyerMooreSearch.mismatch_in_text(0)\n        2\n\n        \"\"\"\n        for i in range(self.patLen - 1, -1, -1):\n            if self.pattern[i] != self.text[current_pos + i]:\n                return i\n        return -1\n\n    def bad_character_heuristic(self):\n        \"\"\"Find all occurrences of the pattern in the text.\n\n        :return: A list of all positions of the pattern in the text, list.\n        >>> boyerMooreSearch = BoyerMooreSearch(\"ABAABA\", \"AB\")\n        >>> boyerMooreSearch.bad_character_heuristic()\n        [0, 3]\n\n        \"\"\"\n        matches = []\n        current_pos = 0\n        while current_pos <= self.textLen - self.patLen:\n            mismatch_pos = self.mismatch_in_text(current_pos)\n            if mismatch_pos == -1:\n                matches.append(current_pos)\n                current_pos += 1\n            else:\n                bad_char = self.text[current_pos + mismatch_pos]\n                match_pos = self.match_in_pattern(bad_char)\n                if match_pos == -1:\n                    current_pos += mismatch_pos + 1\n                else:\n                    current_pos += mismatch_pos - match_pos\n                if current_pos < 0:\n                    current_pos = 1\n        return matches\n"]}
{"task_id": "ClassEval_16", "predict": ["\"\"\"Calculator module for evaluating arithmetic expressions.\"\"\"\n\nimport operator\n\nMIN_OPERANDS = 2\n\n\nclass Calculator:\n    \"\"\"Calculator for arithmetic expressions using +, -, *, /, and ^ operators.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the operations for +, -, *, /, ^ operators.\"\"\"\n        self.operators = {\n            \"+\": operator.add,\n            \"-\": operator.sub,\n            \"*\": operator.mul,\n            \"/\": operator.truediv,\n            \"^\": operator.pow,\n        }\n\n    def calculate(self, expression):\n        \"\"\"Calculate the value of a given expression.\n\n        :param expression: string, given expression\n        :return: If successful, returns the value of the expression; otherwise, returns None\n        >>> calculator = Calculator()\n        >>> calculator.calculate('1+2-3')\n        0.0\n        \"\"\"\n        operand_stack = []\n        operator_stack = []\n\n        i = 0\n        while i < len(expression):\n            if expression[i].isspace():\n                i += 1\n                continue\n\n            if expression[i].isdigit() or (\n                expression[i] == \".\" and i + 1 < len(expression) and expression[i + 1].isdigit()\n            ):\n                num, i = self._parse_number(expression, i)\n                operand_stack.append(num)\n            elif expression[i] in self.operators:\n                while (\n                    operator_stack\n                    and operator_stack[-1] != \"(\"\n                    and operator_stack[-1] in self.operators\n                    and self.precedence(operator_stack[-1]) >= self.precedence(expression[i])\n                ):\n                    self.apply_operator(operand_stack, operator_stack)\n                operator_stack.append(expression[i])\n                i += 1\n            elif expression[i] == \"(\":\n                operator_stack.append(\"(\")\n                i += 1\n            elif expression[i] == \")\":\n                self._handle_close_paren(operand_stack, operator_stack)\n                i += 1\n            else:\n                i += 1\n\n        while operator_stack:\n            self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[0] if operand_stack else None\n\n    @staticmethod\n    def _parse_number(expression, i):\n        num = \"\"\n        while i < len(expression) and (expression[i].isdigit() or expression[i] == \".\"):\n            num += expression[i]\n            i += 1\n        return float(num), i\n\n    @staticmethod\n    def precedence(operator):\n        \"\"\"Return the priority of the specified operator.\n\n        Higher priority means greater precedence. '^' > '*','/' > '+','-'.\n\n        :param operator: string, given operator\n        :return: int, the priority of the given operator, otherwise return 0\n        >>> calculator = Calculator()\n        >>> calculator.precedence('+')\n        1\n        >>> calculator.precedence('^')\n        3\n        \"\"\"\n        if operator in {\"+\", \"-\"}:\n            return 1\n        if operator in {\"*\", \"/\"}:\n            return 2\n        if operator == \"^\":\n            return 3\n        return 0\n\n    def _handle_close_paren(self, operand_stack, operator_stack):\n        while operator_stack and operator_stack[-1] != \"(\":\n            self.apply_operator(operand_stack, operator_stack)\n        if operator_stack:\n            operator_stack.pop()\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"Apply the top operator to the top two operands on the stack.\n\n        :param operand_stack: list\n        :param operator_stack: list\n        :return: the updated operand_stack and operator_stack\n        >>> calculator = Calculator()\n        >>> calculator.apply_operator([1, 2, 3], ['+', '-'])\n        ([1, -1], ['-'])\n        \"\"\"\n        if len(operand_stack) < MIN_OPERANDS or not operator_stack:\n            return\n\n        b = operand_stack.pop()\n        a = operand_stack.pop()\n        op = operator_stack.pop()\n\n        result = self.operators[op](a, b)\n        operand_stack.append(result)\n"]}
{"task_id": "ClassEval_17", "predict": [""]}
{"task_id": "ClassEval_18", "predict": ["\"\"\"CamelCaseMap: dictionary with automatic underscore-to-camelCase key conversion.\"\"\"\n\n\nclass CamelCaseMap:\n    \"\"\"Dictionary-like class that converts underscore keys to camelCase.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize data to an empty dictionary.\"\"\"\n        self._data = {}\n\n    def __getitem__(self, key):\n        \"\"\"Return the value corresponding to the key.\n\n        :param key:str\n        :return:str,the value corresponding to the key\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__getitem__('first_name')\n        'John'\n        \"\"\"\n        return self._data[self._convert_key(key)]\n\n    def __setitem__(self, key, value):\n        \"\"\"Set the value corresponding to the key to the specified value.\n\n        :param key:str\n        :param value:str, the specified value\n        :return:None\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__setitem__('first_name', 'new name')\n        camelize_map['first_name'] = 'new name'\n        \"\"\"\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        \"\"\"Delete the value corresponding to the key.\n\n        :param key:str\n        :return:None\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__delitem__('first_name')\n        >>> flag = 'first_name' in camelize_map\n        flag = False\n        \"\"\"\n        del self._data[self._convert_key(key)]\n\n    def __iter__(self):\n        \"\"\"Return an iterable object over the data.\n\n        :return:Iterator\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map['last_name'] = 'Doe'\n        >>> camelize_map['age'] = 30\n        >>> camelize_map.__iter__()\n        <dict_keyiterator object at 0x0000026739977C20>\n        \"\"\"\n        return iter(self._data)\n\n    def __len__(self):\n        \"\"\"Return the length of the data.\n\n        :return:int, length of data\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map['last_name'] = 'Doe'\n        >>> camelize_map['age'] = 30\n        >>> camelize_map.__len__()\n        3\n        \"\"\"\n        return len(self._data)\n\n    def _convert_key(self, key):\n        \"\"\"Convert key string into camel case.\n\n        :param key:str\n        :return:str, converted key string\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map._convert_key('first_name')\n        'firstName'\n        \"\"\"\n        return self._to_camel_case(key)\n\n    @staticmethod\n    def _to_camel_case(key):\n        \"\"\"Convert key string into camel case.\n\n        :param key:str\n        :return:str, converted key string\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map._to_camel_case('first_name')\n        'firstName'\n        \"\"\"\n        parts = key.split(\"_\")\n        return parts[0] + \"\".join(word.capitalize() for word in parts[1:])\n"]}
{"task_id": "ClassEval_19", "predict": ["\"\"\"Chandrasekhar sieve for generating prime numbers.\"\"\"\n\n\nclass ChandrasekharSieve:\n    \"\"\"Find all prime numbers within a range using Chandrasekhar's Sieve.\"\"\"\n\n    def __init__(self, n):\n        \"\"\"Initialize the ChandrasekharSieve class with the given limit.\n\n        :param n: int, the upper limit for generating prime numbers\n        \"\"\"\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.\n\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.generate_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n        min_prime = 2\n        if self.n < min_prime:\n            return []\n\n        # Initialize a boolean array \"prime[0..n]\" and set all entries as true\n        prime = [True] * (self.n + 1)\n        prime[0] = prime[1] = False\n\n        # Mark all multiples of every prime as not prime\n        p = 2\n        while p * p <= self.n:\n            if prime[p]:\n                for i in range(p * p, self.n + 1, p):\n                    prime[i] = False\n            p += 1\n\n        # Collect all numbers that are marked as prime\n        return [i for i in range(min_prime, self.n + 1) if prime[i]]\n\n    def get_primes(self):\n        \"\"\"Get the list of generated prime numbers.\n\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.get_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n        return self.primes\n"]}
{"task_id": "ClassEval_2", "predict": ["\"\"\"Argument parser module.\"\"\"\n\n\nclass ArgumentParser:\n    \"\"\"This is a class for parsing command line arguments to a dictionary.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the fields.\n\n        self.arguments is a dict that stores the args in a command line\n        self.requried is a set that stores the required arguments\n        self.types is a dict that stores type of every arguments.\n        >>> parser.arguments\n        {'key1': 'value1', 'option1': True}\n        >>> parser.required\n        {'arg1'}\n        >>> parser.types\n        {'arg1': 'type1'}\n        \"\"\"\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n\n    def parse_arguments(self, command_string):\n        \"\"\"Parse the given command line argument string.\n\n        Invoke _convert_type to store the parsed result in specific type\n        in the arguments dictionary. Check for missing required arguments,\n        if any, and return False with the missing argument names, otherwise\n        return True.\n\n        :param command_string: str, command line argument string,\n            formatted like \"python script.py --arg1=value1 -arg2 value2 --option1 -option2\"\n        :return tuple: (True, None) if parsing is successful, (False, missing_args) if parsing fails,\n            where missing_args is a set of the missing argument names which are str.\n        >>> parser.parse_arguments(\"python script.py --arg1=value1 -arg2 value2 --option1 -option2\")\n        (True, None)\n        >>> parser.arguments\n        {'arg1': 'value1', 'arg2': 'value2', 'option1': True, 'option2': True}\n        \"\"\"\n        tokens = command_string.split()\n        i = 0\n        while i < len(tokens):\n            token = tokens[i]\n\n            if token.startswith(\"--\"):\n                # Handle --arg=value or --option\n                if \"=\" in token:\n                    arg, value = token[2:].split(\"=\", 1)\n                    value = self._convert_type(arg, value)\n                    self.arguments[arg] = value\n                else:\n                    arg = token[2:]\n                    self.arguments[arg] = True\n            elif token.startswith(\"-\") and len(token) > 1 and token[1] != \"-\":\n                # Handle -arg value or -option\n                arg = token[1:]\n                if i + 1 < len(tokens) and not tokens[i + 1].startswith(\"-\"):\n                    value = tokens[i + 1]\n                    value = self._convert_type(arg, value)\n                    self.arguments[arg] = value\n                    i += 1\n                else:\n                    self.arguments[arg] = True\n\n            i += 1\n\n        # Check for missing required arguments\n        missing_args = self.required - set(self.arguments.keys())\n        if missing_args:\n            return (False, missing_args)\n        return (True, None)\n\n    def get_argument(self, key):\n        \"\"\"Retrieve the value of the specified argument.\n\n        :param key: str, argument name\n        :return: The value of the argument, or None if the argument does not exist.\n        >>> parser.arguments\n        {'arg1': 'value1', 'arg2': 'value2', 'option1': True, 'option2': True}\n        >>> parser.get_argument('arg2')\n        'value2'\n        \"\"\"\n        return self.arguments.get(key)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        \"\"\"Add an argument to self.types and self.required.\n\n        Check if it is a required argument and store the argument type.\n        If the argument is set as required, it wull be added to the required set.\n        The argument type and name are stored in the types dictionary as key-value pairs.\n        :param arg: str, argument name\n        :param required: bool, whether the argument is required, default is False\n        :param arg_type:str, Argument type, default is str\n        >>> parser.add_argument('arg1', True, 'int')\n        >>> parser.required\n        {'arg1'}\n        >>> parser.types\n        {'arg1': 'int'}\n        \"\"\"\n        if required:\n            self.required.add(arg)\n        self.types[arg] = arg_type\n\n    def _convert_type(self, arg, value):\n        \"\"\"Try to convert the type of input value by searching in self.types.\n\n        :param value: str, the input value in command line\n        :return: return corresponding value in self.types if convert successfully, or the input value oherwise\n        >>> parser.types\n        {'arg1': int}\n        >>> parser._convert_type('arg1', '21')\n        21\n        \"\"\"\n        if arg in self.types:\n            arg_type = self.types[arg]\n            try:\n                return arg_type(value)\n            except (ValueError, TypeError):\n                return value\n        return value\n"]}
{"task_id": "ClassEval_20", "predict": ["\"\"\"Chat module providing multi-user messaging functionality.\"\"\"\n\nfrom datetime import datetime\n\n\nclass Chat:\n    \"\"\"Chat class for adding users, removing users, sending messages, and obtaining messages.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the Chat with an attribute users, which is an empty dictionary.\"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"Add a new user to the Chat.\n\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns False, otherwise, returns True.\n        >>> chat = Chat()\n        >>> chat.add_user('John')\n        True\n        self.users = {'John': []}\n        >>> chat.add_user('John')\n        False\n\n        \"\"\"\n        if username in self.users:\n            return False\n        self.users[username] = []\n        return True\n\n    def remove_user(self, username):\n        \"\"\"Remove a user from the Chat.\n\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns True, otherwise, returns False.\n        >>> chat = Chat()\n        >>> chat.users = {'John': []}\n        >>> chat.remove_user('John')\n        True\n        >>> chat.remove_user('John')\n        False\n\n        \"\"\"\n        if username not in self.users:\n            return False\n        del self.users[username]\n        return True\n\n    def send_message(self, _sender, _receiver, _message):\n        \"\"\"Send a message from a user to another user.\n\n        :param sender: The sender's name, str.\n        :param receiver: The receiver's name, str.\n        :param message: The message, str.\n        :return: If the sender or the receiver is not in the Chat, returns False,\n            otherwise, returns True.\n        >>> chat = Chat()\n        >>> chat.users = {'John': [], 'Mary': []}\n        >>> chat.send_message('John', 'Mary', 'Hello')\n        True\n        >>> chat.send_message('John', 'Tom', 'Hello')\n        False\n\n        \"\"\"\n        if _sender not in self.users or _receiver not in self.users:\n            return False\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        message_dict = {\n            \"sender\": _sender,\n            \"receiver\": _receiver,\n            \"message\": _message,\n            \"timestamp\": timestamp,\n        }\n        self.users[_sender].append(message_dict)\n        self.users[_receiver].append(message_dict)\n        return True\n\n    def get_messages(self, username):\n        \"\"\"Get all the messages of a user from the Chat.\n\n        :param username: The user's name, str.\n        :return: A list of messages, each message is a dictionary with keys\n            'sender', 'receiver', 'message', 'timestamp'.\n        >>> chat = Chat()\n        >>> chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary',\n        ...     'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]}\n        >>> chat.get_messages('John')\n        [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]\n        >>> chat.get_messages('Mary')\n        []\n\n        \"\"\"\n        return self.users.get(username, [])\n"]}
{"task_id": "ClassEval_21", "predict": ["\"\"\"Classroom scheduling and conflict detection.\"\"\"\n\nfrom datetime import datetime\n\n\nclass Classroom:\n    \"\"\"Classroom capable of adding/removing courses and detecting conflicts.\"\"\"\n\n    def __init__(self, classroom_id):\n        \"\"\"Initialize the classroom management system.\n\n        :param classroom_id: int, the id of classroom\n        \"\"\"\n        self.id = classroom_id\n        self.courses = []\n\n    def add_course(self, course):\n        \"\"\"Add course to self.courses list if the course wasn't in it.\n\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"\n        if course not in self.courses:\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        \"\"\"Remove course from self.courses list if the course was in it.\n\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        \"\"\"Change the time format as '%H:%M' and check the time is free or not in the classroom.\n\n        :param check_time: str, the time need to be checked\n        :return: True if the check_time does not conflict with every course time, or False otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.is_free_at('10:00')\n        True\n        >>> classroom.is_free_at('9:00')\n        False\n        \"\"\"\n        check_time_obj = datetime.strptime(check_time, \"%H:%M\")\n        for course in self.courses:\n            start_time_obj = datetime.strptime(course[\"start_time\"], \"%H:%M\")\n            end_time_obj = datetime.strptime(course[\"end_time\"], \"%H:%M\")\n            if start_time_obj <= check_time_obj < end_time_obj:\n                return False\n        return True\n\n    def check_course_conflict(self, new_course):\n        \"\"\"Check if the new course time conflicts with any other course.\n\n        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        :return: False if the new course time conflicts (including two courses have the same\n            boundary time) with other courses, or True otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.check_course_conflict({'name': 'SE', 'start_time': '9:40', 'end_time': '10:40'})\n        False\n        \"\"\"\n        new_start = datetime.strptime(new_course[\"start_time\"], \"%H:%M\")\n        new_end = datetime.strptime(new_course[\"end_time\"], \"%H:%M\")\n        for course in self.courses:\n            start = datetime.strptime(course[\"start_time\"], \"%H:%M\")\n            end = datetime.strptime(course[\"end_time\"], \"%H:%M\")\n            if new_start <= end and start <= new_end:\n                return False\n        return True\n"]}
{"task_id": "ClassEval_22", "predict": ["\"\"\"Class registration system module.\"\"\"\n\n\nclass ClassRegistrationSystem:\n    \"\"\"Class registration system.\n\n    Allows registering students, registering them for classes, retrieving\n    students by major, getting a list of all majors, and determining the\n    most popular class within a specific major.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the registration system.\n\n        students is a list of student dictionaries, each student dictionary has the key of name and major.\n        students_registration_class is a dictionaries, key is the student name, value is a list of class names.\n        \"\"\"\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        \"\"\"Register a student to the system.\n\n        Add the student to the students list.\n        If the student is already registered, return 0, else return 1.\n        \"\"\"\n        student_names = [s[\"name\"] for s in self.students]\n        if student[\"name\"] in student_names:\n            return 0\n        self.students.append(student)\n        return 1\n\n    def register_class(self, student_name, class_name):\n        \"\"\"Register a class to the student.\n\n        :param student_name: str\n        :param class_name: str\n        :return a list of class names that the student has registered\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.register_class(student_name=\"John\", class_name=\"CS101\")\n        >>> registration_system.register_class(student_name=\"John\", class_name=\"CS102\")\n        [\"CS101\", \"CS102\"]\n        \"\"\"\n        if student_name not in self.students_registration_classes:\n            self.students_registration_classes[student_name] = []\n        self.students_registration_classes[student_name].append(class_name)\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        \"\"\"Get all students in the major.\n\n        :param major: str\n        :return a list of student name\n        >>> registration_system = ClassRegistrationSystem()\n        >>> student1 = {\"name\": \"John\", \"major\": \"Computer Science\"}\n        >>> registration_system.register_student(student1)\n        >>> registration_system.get_students_by_major(\"Computer Science\")\n        [\"John\"]\n        \"\"\"\n        return [s[\"name\"] for s in self.students if s[\"major\"] == major]\n\n    def get_all_major(self):\n        \"\"\"Get all majors in the system.\n\n        :return a list of majors\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.students = [{\"name\": \"John\", \"major\": \"Computer Science\"}],\n        >>> registration_system.get_all_major(student1)\n        [\"Computer Science\"]\n        \"\"\"\n        majors = set()\n        majors.update(student[\"major\"] for student in self.students)\n        return list(majors)\n\n    def get_most_popular_class_in_major(self, major):\n        \"\"\"Get the class with the highest enrollment in the major.\n\n        :return  a string of the most popular class in this major\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.students = [{\"name\": \"John\", \"major\": \"Computer Science\"},\n                                             {\"name\": \"Bob\", \"major\": \"Computer Science\"},\n                                             {\"name\": \"Alice\", \"major\": \"Computer Science\"}]\n        >>> registration_system.students_registration_classes = {\"John\": [\"Algorithms\", \"Data Structures\"],\n                                            \"Bob\": [\"Operating Systems\", \"Data Structures\", \"Algorithms\"]}\n        >>> registration_system.get_most_popular_class_in_major(\"Computer Science\")\n        \"Data Structures\"\n        \"\"\"\n        students_in_major = self.get_students_by_major(major)\n        class_count = {}\n        for student_name in students_in_major:\n            if student_name in self.students_registration_classes:\n                for class_name in self.students_registration_classes[student_name]:\n                    class_count[class_name] = class_count.get(class_name, 0) + 1\n        return max(class_count, key=lambda x: class_count[x]) if class_count else None\n"]}
{"task_id": "ClassEval_23", "predict": ["\"\"\"Combination calculator module.\"\"\"\n\nimport math\n\n\nclass CombinationCalculator:\n    \"\"\"Provide methods to calculate and generate combinations.\"\"\"\n\n    def __init__(self, datas: list[str]):\n        \"\"\"Initialize the calculator with a list of data.\"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"Calculate the number of combinations for a specific count.\n\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"\n        return math.comb(n, m)\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"Calculate the number of all possible combinations.\n\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,\n            if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"\n        max_bits = 63\n        if n > max_bits:\n            return float(\"inf\")\n        return 2**n - 1\n\n    def select(self, m: int) -> list[list[str]]:\n        \"\"\"Generate combinations with a specified number of elements.\n\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result\n\n    def select_all(self) -> list[list[str]]:\n        \"\"\"Generate all possible combinations of selecting elements from the data list.\n\n        Uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()  # doctest: +NORMALIZE_WHITESPACE\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'],\n        ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'],\n        ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"\n        results = []\n        for i in range(1, len(self.datas) + 1):\n            results.extend(self.select(i))\n        return results\n\n    def _select(self, data_index: int, result_list: list[str], result_index: int, result: list[list[str]]):\n        \"\"\"Generate combinations with a specified number of elements by recursion.\n\n        :param data_index: The index of the data to be selected,int.\n        :param result_list: The list of elements in the combination,List[str].\n        :param result_index: The index of the element in the combination,int.\n        :param result: The list of combinations,List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n        if result_index == len(result_list):\n            result.append(list(result_list))\n            return\n        for i in range(data_index, len(self.datas)):\n            result_list[result_index] = self.datas[i]\n            self._select(i + 1, result_list, result_index + 1, result)\n"]}
{"task_id": "ClassEval_24", "predict": ["\"\"\"Complex number calculator module.\"\"\"\n\n\nclass ComplexCalculator:\n    \"\"\"Implement arithmetic operations for complex numbers.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize ComplexCalculator.\"\"\"\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        \"\"\"Add two complex numbers.\n\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The sum of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.add(1+2j, 3+4j)\n        (4+6j)\n\n        \"\"\"\n        return c1 + c2\n\n    @staticmethod\n    def subtract(c1, c2):\n        \"\"\"Subtract two complex numbers.\n\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The difference of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.subtract(1+2j, 3+4j)\n        (-2-2j)\n\n        \"\"\"\n        return c1 - c2\n\n    @staticmethod\n    def multiply(c1, c2):\n        \"\"\"Multiply two complex numbers.\n\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The product of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.multiply(1+2j, 3+4j)\n        (-5+10j)\n\n        \"\"\"\n        return c1 * c2\n\n    @staticmethod\n    def divide(c1, c2):\n        \"\"\"Divide two complex numbers.\n\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The quotient of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.divide(1+2j, 3+4j)\n        (0.44+0.08j)\n\n        \"\"\"\n        return c1 / c2\n"]}
{"task_id": "ClassEval_25", "predict": ["\"\"\"Utility module for managing and manipulating cookies.\"\"\"\n\nimport json\n\n\nclass CookiesUtil:\n    \"\"\"Utility for managing and manipulating cookies.\"\"\"\n\n    def __init__(self, cookies_file):\n        \"\"\"Initialize the CookiesUtil with the specified cookies file.\n\n        :param cookies_file: The cookies file to use, str.\n        \"\"\"\n        self.cookies_file = cookies_file\n        self.cookies = None\n\n    def get_cookies(self, reponse):\n        \"\"\"Get the cookies from the specified response and save to cookies_file.\n\n        :param reponse: The response to get cookies from, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.get_cookies({'cookies': {'key1': 'value1', 'key2': 'value2'}})\n        >>> cookies_util.cookies\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n        self.cookies = reponse[\"cookies\"]\n        self._save_cookies()\n\n    def load_cookies(self):\n        \"\"\"Load the cookies from the cookies_file to the cookies data.\n\n        :return: The cookies data, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.load_cookies()\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n        try:\n            with open(self.cookies_file, encoding=\"utf-8\") as f:\n                self.cookies = json.load(f)\n        except Exception:\n            return {}\n        else:\n            return self.cookies\n\n    def _save_cookies(self):\n        \"\"\"Save the cookies to the cookies_file.\n\n        :return: True if successful, False otherwise.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.cookies = {'key1': 'value1', 'key2': 'value2'}\n        >>> cookies_util._save_cookies()\n        True\n\n        \"\"\"\n        try:\n            with open(self.cookies_file, \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.cookies, f)\n        except Exception:\n            return False\n        else:\n            return True\n"]}
{"task_id": "ClassEval_26", "predict": ["\"\"\"CSV file processing utilities.\"\"\"\n\nimport csv\n\n_SPLIT_PARTS_COUNT = 2\n\n\nclass CSVProcessor:\n    \"\"\"Process CSV files, including reading and writing CSV data.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize CSVProcessor.\"\"\"\n        pass\n\n    @staticmethod\n    def read_csv(file_name):\n        \"\"\"Read the csv file by file_name, get the title and data from it.\n\n        :param file_name: str, name of the csv file\n        :return title, data: (list, list), first row is title, the rest is data\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        \"\"\"\n        try:\n            with open(file_name, encoding=\"utf-8\") as file:\n                reader = csv.reader(file)\n                rows = list(reader)\n                if len(rows) > 0:\n                    title = rows[0]\n                    data = rows[1:]\n                    return title, data\n                return [], []\n        except Exception:\n            return [], []\n\n    @staticmethod\n    def write_csv(data, file_name):\n        \"\"\"Write data into a csv file.\n\n        :param file_name: str, name of the csv file\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.write_csv([['a', 'b', 'c', 'd'], ['1', '2', '3', '4']], 'write_test.csv')\n        1\n        \"\"\"\n        try:\n            with open(file_name, \"w\", newline=\"\", encoding=\"utf-8\") as file:\n                writer = csv.writer(file)\n                writer.writerows(data)\n        except Exception:\n            return 0\n        else:\n            return 1\n\n    @staticmethod\n    def process_csv_data(_n, _save_file_name):\n        \"\"\"Read a csv file into variable title and data.\n\n        Only remain the n th (from 0) column data and Capitalize them, store the title and new data into a new csv file.\n        Add '_process' suffix after old file name, as a new file name.\n        :param n: int, the n th column(from 0)\n        :param save_file_name, the name of file that needs to be processed.\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        >>> csvProcessor.process_csv_data(0, 'read_test.csv')\n        1\n        >>> csvProcessor.read_csv('read_test_process.csv')\n        (['a', 'b', 'c', 'd'], [['HELLO']])\n        \"\"\"\n        try:\n            title, data = CSVProcessor.read_csv(_save_file_name)\n            if not title or not data:\n                return 0\n\n            new_data = [[row[_n].upper()] for row in data if _n < len(row)]\n\n            parts = _save_file_name.rsplit(\".\", 1)\n            new_file_name = (\n                f\"{parts[0]}_process.{parts[1]}\" if len(parts) == _SPLIT_PARTS_COUNT else f\"{_save_file_name}_process\"\n            )\n\n            output_data = [title, *new_data]\n            return CSVProcessor.write_csv(output_data, new_file_name)\n        except Exception:\n            return 0\n"]}
